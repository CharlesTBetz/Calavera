# abandoned for now due to increasing complexity
# this approach would have given each machine its own public/private key pair
# but due to ordering issues there was still insecurity - the entire set of pairs for the whole cluster had to be generated immediately
# and the script was becoming difficult to understand
# going to simply share one public/private key pair across the cluster
# but regenerate it if /mnt/public/keys is emptied

# this script should be sourced by all provisioning scripts
# every host should have a unique key pair created upon initial provisioning
# we don't want just one permanent set for whole cluster so it can't go in BakeCalavera.sh
# (tempting but we need at least adequate security)
# nor do we want keys in github, so both .ssh and rsa* are in gitignore.

# Ok here is the business rule
# ssh.sh runs every time
# and checks that every host has a key
# generates for those that do not
# finds its own hosts key
# downloads and deletes private key
# inserts public key from all other hosts in ~/.ssh/authorized_keys
# we need a list of all machines in cluster
# this script assumes that private keys may be moved but that public keys stay put
# if it detects neither key it regenerates. 


echo configuring ssh

mkdir -p /mnt/public/keys  # -p = no error if it exists (idempotent)


for OUTPUT in $(cat /mnt/public/calaverahosts)   # test each host name against keys in directory

do
    # echo testing $OUTPUT against $(ls /mnt/public/keys)
    if [[ $(ls /mnt/public/keys) !=  *$OUTPUT* ]]; # if the host name $OUTPUT cannot be found anywhere *$OUTPUT* in the directory listing
    then
        echo generating keys for $OUTPUT
        ssh-keygen -q -t rsa -f /mnt/public/keys/id_rsa_$OUTPUT -P "" -C "*** Key auto-generated on Vagrant provisioning \
        for Calavera project node $HOSTNAME on \
        "$(date +%F)" "$(date +%T)" UTC ***"
        
        #echo -e  'y\n'|ssh-keygen -q -t rsa -f id_rsa_$HOSTNAME -P "" -C "*** Key auto-generated on Vagrant provisioning \
        #for Calavera project node $HOSTNAME on \
        #"$(date +%F)" "$(date +%T)" UTC ***"
        
    fi
    
    if [[ $OUTPUT == $HOSTNAME ]];  #force update the host's keys from the public folder
    then        
        echo $OUTPUT is host, copying public key
        cp -f /mnt/public/keys/id_rsa_$HOSTNAME.pub ~/.ssh #public keys are left in the shared folder for ease of installation.
        # echo testing $(ls /mnt/public/keys) against *\<id_rsa_$HOSTNAME\>*
        if [[ $(ls /mnt/public/keys) ==  *id_rsa_$HOSTNAME[^\.]* ]];  # is the private key still there (generated by other node?)
        then
            echo moving private key
            mv -f /mnt/public/keys/id_rsa_$HOSTNAME ~/.ssh/  #private keys are immediately moved. window of vulnerability should be small. 
        
        fi #but there is a case where machine 1 gens key, left there till machine 5
    else
        
    #     this is not the host -  we don't want the host's public key in authorized_keys but we want all the others
        if [[ $(cat ~/.ssh/authorized_keys) !=  *$OUTPUT* ]];                # is the public key in there?
        then
            # putting public key id_rsa_$HOSTNAME.pub into authorized_keys
            cat /mnt/public/keys/id_rsa_$HOSTNAME.pub >> authorized_keys    # every host should allow every other. 
        fi
    fi
    
done